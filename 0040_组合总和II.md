## 40 组合总和II

**题目：**

给定一个数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。

candidates中的每个数字在每个组合中只能使用一次。

说明：所有数字（包括目标数）都是正整数。解集不能包含重复的组合。



**思路：**

集合（数组candidates）有重复元素，但还不能有重复的组合。

思路1：先把所有组合求出来，再用set或者map去重。这样很容易超时

思路2：在搜索过程中就将重复组合去除。



所谓去重，其实就是使用过的元素不能重复选取。

都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的。

一个维度是**同一树枝**上使用过，一个维度是**同一树层**上使用过。

**没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。**



那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？

回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。

**所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重**。



**强调一下，树层去重的话，需要对数组排序！**

<img src="https://img-blog.csdnimg.cn/20201123202736384.png" alt="40.组合总和II" style="zoom: 33%;" />

**代码实现：**

```java
class Solution {
    List<List<Integer>> lists = new ArrayList<>();
    Deque<Integer> deque = new LinkedList<>();
    
    int sum = 0;
    
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        // 为了将重复的数字都放到一起，所以先进行排序
        Arrays.sort(candidates);
        // 加标志数组，用来辅助判断同层节点是否已经遍历
        boolean[] flag = new boolean[candidates.length];
        
        backTracking(candidates, target, 0, flag);
        return lists;
    }
    
    public void backTracking(int[] arr, int target, int index, boolean[] flag) {
        if (sum == target) {
            lists.add(new ArrayList(deque));
            return;
        }
        
        for (int i = index; i < arr.length && arr[i] + sum <= target; i++) {
            // 出现重复节点，同层的第一个节点已经被访问过，所以直接跳过
            if (i > 0 && arr[i] == arr[i - 1] && !flag[i - 1]) {
                continue;
            }
            
            // ------------------------------------------- //
            // 这里是向下搜索
            flag[i] = true;
            sum += arr[i];
            deque.push(arr[i]);
            // 每个节点仅能选择一次，所以从下一位开始
            backTracking(arr, target, i + 1, flag);
            
            // ------------------------------------------- //
            // 这里是横向搜索
            int temp = deque.pop();
            flag[i] = false;
            sum -= temp;
        }
    }
}
```


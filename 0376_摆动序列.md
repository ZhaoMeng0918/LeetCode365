# 376 摆动序列

**题目：**

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。



给定一个整数序列，返回作为**摆动序列的最长子序列的长度**。通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。



**思路：**

局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。

整体最优：整个序列有多个局部峰值，从而达到最长摆动序列。



**实际上就是统计峰值的数量即可**



![376.摆动序列](https://img-blog.csdnimg.cn/20201124174327597.png)

**代码实现：**

```c++
class Solution {
    public:
    	int wiggleMaxLength(vector<int>& nums) {
            if(nums.size() <= 1) {
                return nums.size();
            }
            
            int curDiff = 0; // 当前一对差值
            int preDiff = 0; // 前一对差值
            int result = 1;  // 记录峰值个数，序列默认序列最右边有1个峰值
            
            for(int i = 0; i < nums.size() - 1; i++) {
                curDiff = nums[i + 1] - nums[i];
                // 出现峰值
                if((curDiff > 0 && preDiff <= 0) || (preDiff >= 0 && curDiff < 0)) {
                    result++;
                    preDiff = curDiff;
                }
            }
            
            return result;
        }
}
```



**总结：**

**贪心的题目说简单有的时候就是常识，说难就难在都不知道该怎么用贪心**。

而这道题目有什么技巧说一下子能想到贪心么？

其实也没有，类似的题目做过了就会想到。

此时大家就应该了解了：**保持区间波动，只需要把单调区间上的元素移除就可以了**。


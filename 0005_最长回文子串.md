# 5 最长回文子串

**题目：**

给你一个字符串s，找到s中最长的回文子串。



**思路1：**

暴力破解法

```java
public class Solution1 {
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len < 2) {
            return s;
        }
        int maxLen = 1;
        int begin = 0;
        char[] cs = s.toCharArray();
        for(int i = 0; i < len - 1; i++) {
            for(int j = i + 1; j < len; j++) {
                if(j - i + 1 > maxLen && isPalindrome(cs, i, j)) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
    
    private boolean isPalindrome(char[] cs, int i, int j) {
        while(i < j) {
            if(cs[i] != cs[j]) {
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
} 
```

**思路2：**

中心扩散法

基本思想是：遍历每一个下标，以这个下标为中心，利用回文串中心对称的特点，往两边扩散，看最多能扩散多远。

枚举中心位置时间复杂度为O(N)，从中心位置扩散得到回文子串的时间复杂度为O(N)，因此时间复杂度可以降到O(N^2)

细节：回文串在长度为奇数和偶数的时候，回文中心的形态不一样。

- 奇数回文串的中心是一个具体的字符，例如：回文串"aba"的中心是字符"b"；
- 偶数回文串的中心是位于中间的两个字符的空隙，例如：回文串"abba"的中心是两个"b"，也可以看成两个"b"中间的空隙。

![image.png](https://pic.leetcode-cn.com/1617703338-JVaHRZ-image.png)

我们看一下一个字符串可能的回文子串的中心都在哪里？

![image.png](https://pic.leetcode-cn.com/1617703406-EtKaXI-image.png)

我们可以设计一个方法，兼容以上两种情况：

- 如果传入重合的下标，进行中心扩散，此时得到的回文子串长度是奇数；
- 如果传入相邻的下标，进行中心扩散，此时得到的回文子串长度是偶数。

代码实现：

```java
public class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len < 2) {
            return s;
        }
        
        int maxLen = 0;
        int[] res = new int[2]; // 数组第一位记录起始位置，第二位记录长度
        for(int i = 0; i < len - 1; i++) {
            int[] odd = centerSpread(s, i, i);
            int[] even = centerSpread(s, i, i+1);
            int[] max = odd[1] > even[1] ? odd : even;
            if(max[1] > maxLen) {
                res = max;
                maxLen = max[i]
            }
        }
        return s.substring(res[0], res[0] + res[1]);
    }
    
    private int[] centerSpread(String s, int left, int right) {
        int len = s.length();
        while(left >= 0 && right < len) {
            if(s.charAt(left) == s.charAt(right)) {
                left--;
                right++;
            } else {
                break;
            }
        }
        return new int[]{left + 1, right - left - 1};
    }
}
```



**思路3：**

动态规划



思路4：

Manacher法
























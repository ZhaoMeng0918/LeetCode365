# 101 对称二叉树

题目：

给定一个二叉树，检查它是否是镜像对称的。



思路：

**首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！**

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两个树（这两个树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

那么如果比较呢？

比较的是两个子树的里侧和外侧的元素是否相等。如图所示：

<img src="https://img-blog.csdnimg.cn/20210203144624414.png" alt="101. 对称二叉树1" style="zoom:50%;" />

那么遍历的顺序应该是什么样的呢？

本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。

**正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。**

但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。

其实后序也可以理解为是一种回溯，当然这是题外话，讲回溯的时候会重点讲的。

说到这大家可能感觉我有点啰嗦，哪有这么多道理，上来就干就完事了。别急，我说的这些在下面的代码讲解中都有身影。



**递归法：**

递归三部曲：

1. 确定递归函数的参数和返回值

   因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。

   返回值自然是bool类型。

   代码如下：

   ```c++
   bool compare(TreeNode* left, TreeNode* right)
   ```

2. 确定终止条件

   要比较两个节点数值相不相同，首先要把两个节点为空的情况的情况弄清楚。否则后面比较数值的时候就会操作空指针了。

   节点为空的情况有：（**注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点**）

   - 左节点为空，右节点不为空，不对称，return false
   - 左不为空，右为空，不对称 return false
   - 左右都为空，对称，返回true

   此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：

   - 左右都不为空，比较节点数值，不相同就return false

   此时左右节点不为空，且数值也不相同的情况我们也处理了。

   ```c++
   if(left == NULL && right != NULL) return false;
   else if(left != NULL && right == NULL) return false;
   else if(left == NULL && right == NULL) return true;
   else if(left->val != right->val) return false;
   ```

   注意上面最后一种情况，我没有使用else，而是elseif， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。

3. 确定单层递归的逻辑

   此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。

   - 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
   - 比较内测是否对称，传入左节点的右孩子，右节点的左孩子。
   - 如果左右都对称就返回true ，有一侧不对称就返回false 。

   ```c++
   bool outside = compare(left->left, right->right);
   bool inside = compare(left->right, right->right);
   bool isSame = outside && inside;
   return isSame;
   ```

   

整体代码：



```c++
class Solution {
    public:
    	bool compare(TreeNode* left, TreeNode* right) {
            if(left == NULL && right != NULL) return false;
            else if(left != NULL && right == NULL) return false;
            else if(left == NULL && right == NULL) return true;
            else if(left->val != right->val) return false;
            
            bool outside = compare(left->left, right->right);
            bool inside = compare(left->right, right->left);
            return outside && inside;
        }
}
```



**迭代法：**

这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。

使用队列

通过使用队列来判断左子树和右子树的内侧和外侧是否相等。

![101.对称二叉树](https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif)

```java
// 迭代法：双端队列
public boolean isSymmetric2(TreeNode root) {
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offerFirst(root.left);
        deque.offerLast(root.right);
        while (!deque.isEmpty()) {
            TreeNode leftNode = deque.pollFirst();
            TreeNode rightNode = deque.pollLast();
            if (leftNode == null && rightNode == null) {
                continue;
            }
//            if (leftNode == null && rightNode != null) {
//                return false;
//            }
//            if (leftNode != null && rightNode == null) {
//                return false;
//            }
//            if (leftNode.val != rightNode.val) {
//                return false;
//            }
            // 以上三个判断条件合并
            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {
                return false;
            }
            deque.offerFirst(leftNode.left);
            deque.offerFirst(leftNode.right);
            deque.offerLast(rightNode.right);
            deque.offerLast(rightNode.left);
        }
        return true;
    }

// 迭代法：普通队列
public boolean isSymmetric(TreeNode root){
    Queue<TreeNode> deque = new LinkedList<>();
    deque.offer(root.left);
    deque.offer(root.right);
    while(!deque.isEmpty()) {
        TreeNode leftNode = deque.poll();
        TreeNode rightNode = deque.poll();
        if(leftNode == NULL && rightNode == NULL) {
            continue;
        }
//      if (leftNode == null && rightNode != null) {
//          return false;
//      }
//      if (leftNode != null && rightNode == null) {
//          return false;
//      }
//      if (leftNode.val != rightNode.val) {
//          return false;
//      }
        // 以上三个判断条件合并
        if(leftNode == null || rightNode == null || leftNode.val != rightNode.val) {
                return false;
        }
        deque.offer(leftNode.left);
        deque.offer(rightNode.right);
        deque.offer(leftNode.right);
        deque.offer(rightNode.left);
    }
    return true;
}
```




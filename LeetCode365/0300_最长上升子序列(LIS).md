# 300 最长上升子序列(LIS)

###### 题目：

给定一个无序的整数数组，找到其中最长上升子序列的长度。



## 解法一：动态规划

###### 模型讲解：

减小长度，从小规模的问题着手思考。

如果长度为1，答案等于多少？很显然为1。

长度为2，那我们需要考虑第二个数是否比第一个数大，如果比第一个数大，则答案为2，否则为1。

长度为3呢？那么我们需要枚举第三个数是否比第二个数或第一个数大，如果比它大，那可以直接从第二个数或第一个数的答案转移而来。

因此，我们可以如下制定DP状态，f[i]表示仅考虑前i个数，以第i个数为结尾的最长上升子序列的最大长度。

由此我们可以推出如下转移方程：

f[i] = max(1, f[j] + 1), a[j] < a[i], j < i

该模型DP状态的关键在于固定了最后一个数字，而这样做的原因在于对于一个最长上升子序列，我们只需要关注它最后一个数字，对于其前面的数字我们并不关心。

该模型的时间复杂度为O(n^2)，其中n为数组长度。另外，该模型还可以用二分优化到O(nlogn)。

```c++
class Solution {
  public:
    int lengthOfLIS(vector<int>& nums) {
        int sz = nums.size(), ans = 0;
        vector<int> f(sz, 0);
        for(int i = 0; i < sz; i++) {
            int tmp = 1;
            for(int j = i - 1; j >= 0; j--) {
                if(nums[i] > nums[j])
                    tmp = max(tmp, f[j] + 1);
            }
            f[i] = tmp;
            ans = max(ans, tmp);
        }
        return ans;
    }
};
```



## 解法二：动态规划+二分查找

```java
// Dynamic programming + Dichotomy.
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] tails = new int[nums.length];
        int res = 0;
        for(int num : nums) {
            int i = 0, j = res;
            while(i < j) {
                int m = (i + j) / 2;
                if(tails[m] < num) i = m + 1;
                else j = m;
            }
            tails[i] = num;
            if(res == j) res++;
        }
        return res;
    }
}
```








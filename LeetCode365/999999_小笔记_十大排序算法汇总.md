```java
package com.gerryZhao;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;

public class Main {

    public static void main(String[] args) {
        int[] arr = new int[]{7, 12, 2, 6, 9, 8, 4, 5};
        // quickSort(arr, 0, arr.length - 1);
        // mergeSort(arr, 0, arr.length - 1, new int[arr.length]);
        // heapSort(arr);
        // arr = countingSort(arr);
        // buckerSort(arr);
        // radixSort(arr);
        for (int a : arr) {
            System.out.println(a);
        }
    }

    public static int[] twoSum(int[] nums, int target) {
        // 方法四：排序后折半查找，时间复杂度为

        // 拷贝一个新数组
        int[] nums2 = new int[nums.length];
        for (int i = 0; i < nums2.length; i++) {
            nums2[i] = nums[i];
        }

        // 1. 按照从小到大的顺序排序
        // 1.1 冒泡排序 往后冒
        for (int i = 0; i < nums2.length - 1; i++) {
            boolean flag = true;
            for (int j = 0; j < nums2.length - 1 - i; j++) {
                if (nums2[j] > nums2[j + 1]) {
                    int tmp = nums2[j];
                    nums2[j] = nums2[j + 1];
                    nums2[j + 1] = tmp;
                    flag = false;
                }
                if (flag) {
                    break;
                }
            }

        }

        // 1.2 选择排序 选择一个向前插
        for (int i = 0; i < nums2.length - 1; i++) {
            int index = i;
            for (int j = i + 1; j < nums2.length; j++) {
                if (nums2[j] < nums2[index]) {
                    index = j;
                }
            }

            int tmp = nums2[index];
            nums2[index] = nums2[i];
            nums2[i] = tmp;
        }

        // 1.3 插入排序 前面有序数组里面插入
        for (int i = 0; i < nums2.length; i++) {
            int insertVal = nums2[i];
            int insertIndex = i - 1;
            while (insertIndex >= 0 && insertVal < nums2[insertIndex]) {
                nums2[insertIndex + 1] = nums2[insertIndex];
                insertIndex--;
            }
            nums2[insertIndex + 1] = insertVal;
        }

        // 1.4 希尔排序 分组插入排序
        for (int gap = nums2.length / 2; gap > 0; gap /= 2) {
            for (int i = gap; i < nums2.length; i++) {
                for (int j = i - gap; j >= 0; j -= gap) {
                    if (nums2[j] > nums2[j + gap]) {
                        int tmp = nums2[j];
                        nums2[j] = nums2[j + gap];
                        nums2[j + gap] = tmp;
                    }
                }
            }
        }

        // 1.5 快速排序
        quickSort(nums2, 0, nums2.length - 1);

        // 1.6 归并排序，时间复杂度为O（nlogn）
        // 以空间换时间
        mergeSort(nums2, 0, nums2.length - 1, new int[nums2.length]);

        // 1.7 堆排序（大顶堆）
        heapSort(nums2);

        // 1.8 计数排序，时间复杂度为O(n)
        int[] nums3 = countingSort(nums2);

        // 1.9 桶排序，时间复杂度为O(n)
        buckerSort(nums2);

        // 1.10 基数排序
        // 按记录关键字的各位值逐步进行排序的方法
        radixSort(nums2);
        
        return nums2;
    }

    public static void quickSort(int[] arr, int low, int high) {
        if (low > high) {
            return;
        }

        int pivot = arr[low],
                i = low,
                j = high,
                tmp;

        while (i < j) {
            while (arr[j] >= pivot && i < j) {
                j--;
            }

            while (arr[i] <= pivot && i < j) {
                i++;
            }

            if (i < j) {
                tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }

        arr[low] = arr[i];
        arr[i] = pivot;
        quickSort(arr, low, i - 1);
        quickSort(arr, j + 1, high);
    }

    public static void mergeSort(int[] arr, int left, int right, int[] tmp) {
        // 分解
        if (left < right) {
            int mid = (left + right) / 2;
            // 向左递归进行分解
            mergeSort(arr, left, mid, tmp);
            // 向右递归进行分解
            mergeSort(arr, mid + 1, right, tmp);
            // 每分解一次便合并一次
            merge(arr, left, right, mid, tmp);
        }
    }

    /**
     * @param arr   待排序数组
     * @param left  左边有序序列的初始索引
     * @param right 右边有序序列的初始索引
     * @param mid   中间索引
     * @param tmp   做中转的数组
     */
    private static void merge(int[] arr, int left, int right, int mid, int[] tmp) {
        int i = left;
        int j = mid + 1;
        int t = 0;

        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                tmp[t] = arr[i];
                t++;//索引向后移
                i++;//i后移
            } else {
                tmp[t] = arr[j];
                t++;
                j++;
            }
        }

        while (i <= mid) {
            tmp[t] = arr[i];
            t++;
            i++;
        }

        while (j <= right) {
            tmp[t] = arr[j];
            t++;
            j++;
        }

        t = 0;

        // 将tmp数组的元素复制到原数组
        int tempLeft = left;
        while (tempLeft <= right) {
            arr[tempLeft] = tmp[t];
            t++;
            tempLeft++;
        }
    }

    public static void heapSort(int[] arr) {
        int length = arr.length;

        // 构建堆
        buildHeap(arr, length);

        for (int i = length - 1; i > 0; i--) {
            // 将堆顶元素与末尾元素调换
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // 数组长度-1，隐藏堆尾元素
            length--;

            // 将堆顶元素下沉，目的是将最大的元素浮到堆顶来
            sink(arr, 0, length);
        }

    }

    private static void buildHeap(int[] arr, int length) {
        for (int i = length / 2; i >= 0; i--) {
            sink(arr, i, length);
        }
    }

    private static void sink(int[] arr, int index, int length) {
        int leftChild = 2 * index + 1;
        int rightChild = 2 * index + 2;
        int present = index; // 要调整的节点下标

        // 下沉左边
        if (leftChild < length && arr[leftChild] > arr[present]) {
            present = leftChild;
        }

        // 下沉右边
        if (rightChild < length && arr[rightChild] > arr[present]) {
            present = rightChild;
        }

        // 如果下标不相等，证明调换过了
        if (present != index) {
            int temp = arr[index];
            arr[index] = arr[present];
            arr[present] = temp;

            // 继续下沉
            sink(arr, present, length);
        }
    }

    /**
     * @param arr
     * @param flag true: max; false: min
     * @return
     */
    private static int findMaxOrMinElement(int[] arr, boolean flag) {
        int tmp = arr[0];
        if (flag) {
            for (int val : arr) {
                if (val > tmp) {
                    tmp = val;
                }
            }
        } else {
            for (int val : arr) {
                if (val < tmp) {
                    tmp = val;
                }
            }
        }
        return tmp;
    }

    private static int[] countingSort(int[] arr) {
        int[] output = new int[arr.length];

        int range = findMaxOrMinElement(arr, true) + 1;
        int[] count = new int[range];

        // 统计每个元素出现的次数
        for (int i = 0; i < arr.length; i++) {
            count[arr[i]]++;
        }

        // 统计数组做变形，后边的元素等于前面的元素之和
        for (int i = 1; i < range; i++) {
            count[i] = count[i] + count[i - 1];
        }

        for (int i = 0; i < arr.length; i++) {
            output[count[arr[i]] - 1] = arr[i];
            count[arr[i]]--;
        }

        return output;
    }

    public static void buckerSort(int[] arr) {
        // 桶列表
        ArrayList<ArrayList<Integer>> buckets = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
            buckets.add(new ArrayList<>());
        }

        int max = findMaxOrMinElement(arr, true);
        int min = findMaxOrMinElement(arr, false);
        // 切记: 这里一定是float类型
        float section = (float) (max - min) / (float) (arr.length - 1);

        // 数据入桶
        for (int i = 0; i < arr.length; i++) {
            // 当前数除以区间得出存放桶的位置，减一后得出桶的下标
            int num = (int) (arr[i] / section) - 1;
            if (num < 0) {
                num = 0;
            }

            buckets.get(num).add(arr[i]);
        }

        // 桶内排序
        for (int i = 0; i < buckets.size(); i++) {
            Collections.sort(buckets.get(i));
        }

        // 写入原数组
        int index = 0;
        for (ArrayList<Integer> arrayList : buckets) {
            for (int value : arrayList) {
                arr[index] = value;
                index++;
            }
        }
    }

    public static void radixSort(int[] arr) {
        int max = findMaxOrMinElement(arr, true);

        for (int exp = 1; max / exp > 0; exp *= 10) {
            // 存储待排序元素的临时数组
            int[] temp = new int[arr.length];

            // 分桶个数
            int[] buckets = new int[10];

            // 将数据出现的次数存储在buckets中
            for (int value : arr) {
                // (value / exp) % 10 :value的最底位(个位)
                buckets[(value / exp) % 10]++;
            }

            // 更改buckets[i]
            for (int i = 1; i < 10; i++) {
                buckets[i] += buckets[i - 1];
            }

            // 将数据存储到临时数组temp中
            for (int i = arr.length - 1; i >= 0; i--) {
                temp[buckets[(arr[i] / exp) % 10] - 1] = arr[i];
                buckets[(arr[i] / exp) % 10]--;
            }

            // 将有序元素temp赋给arr
            System.arraycopy(temp, 0, arr, 0, arr.length);
        }
    }
}
```


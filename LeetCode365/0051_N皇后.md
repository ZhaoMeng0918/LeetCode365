# 51 N皇后

**题目：**

n皇后问题研究的是如何将n个皇后放在nxn的棋盘上，并且使皇后彼此之间不能互相攻击。

给你一个整数n，返回所有不同的n皇后问题的解决方案。

每一种解法包含一个不同的n皇后问题的棋子放置方案，该方案中Q和.分别代表了皇后和空位。



**思路：**

都知道n皇后问题是回溯算法解决的经典问题，但是用回溯解决多了组合、切割、子集、排列问题之后，遇到这种二维矩阵还会有点不知所措。

首先来看一下皇后们的约束条件：

1. 不能同行
2. 不能同列
3. 不能同斜线

确定完约束条件，来看看究竟要怎样去搜索皇后们的位置，起始搜索皇后的位置，可以抽象为一棵树。



1、将第一个皇后放置在第一行的第一个空格里

2、对于第二行，从第一个空格开始寻找不与第一行的皇后冲突的空格。找到的第一个不冲突的空格是第2个。

3、对于第三行，这时已经找不到与之前放置的两个皇后不冲突的空格了。把当前行恢复初始状态，返回到上一行。

4、在当前行皇后所占的空格之后寻找一个不与之前皇后冲突的位置。有两种情况，如果找打了则把当前行的皇后移动到该位置，然后处理下一行。如果直到最后当前行的最后一个空格也没有找合适的位置，则把当前行恢复初始状态，继续回溯到上一行。

5、把最后一个皇后成功安置在最后一行，代表找到了一种可行解。返回步骤4。

6、当需要回溯到第0行（表格之外）的时候代表已经找遍了所有可能的可行解。



代码实现：

```java
class Solution {
    List<List<String>> res = new ArrayList<>();
    
    public List<List<String>> solveNQueens(int n) {
        char[][] chessboard = new char[n][n];
        for (char[] c : chessboard) {
            Arrays.fill(c, '.');
        }
        // n：棋牌的大小
        // row：记录当前遍历到棋盘的第几层了
        backTrack(n, 0, chessboard);
        return res;
    }
    
    public void backTrack(int n, int row, char[][] chessboard) {
        if (row == n) {
            res.add(Array2List(chessboard));
            return;
        }
        
        for(int col = 0; col < n; col++) {
            if(isValid(row, col, n, chessboard)) {
                chessboard[row][col] = 'Q';
                backTrack(n, row+1, chessboard);
                chessboard[row][col] = '.';
            }
        }
    }
    
    public List Array2List(char[][] chessboard) {
        List<String> list = new ArrayList<>();

        for (char[] c : chessboard) {
            list.add(String.copyValueOf(c));
        }
        return list;
    }
    
    public boolean isValid(int row, int col, int n, char[][] chessboard) {
        // 检查列
        for(int i = 0; i < row; i++) {
            if(chessboard[i][col] == 'Q') { // 解决当前问题的时候就不要考虑后面的节点
                return false;
            }
        }
        
        // 检查45°对角线
        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if(chessboard[i][j] == 'Q') {
                return false;
            }
        }
        
        // 检查135°对角线
        for(int i = row - 1, j = col + 1; i >= 0 && j <= n - 1; i--, j++) {
            if(chessboard[i][j] == 'Q') {
                return false;
            }
        }
    }
}
```


# 152 乘积最大子数组

题目：给你一个数组nums，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

解题思路：动态规划，宝石挑选进阶版问题。

令f[i]表示以i为右端点的连续区间最大乘积，即可将原问题划分为多个求最优值得子问题，但这个状态定义是否符合最优子结构原则呢？

举例：

给出nums = [2, -1, -2]，根据上述f[i]的定义，我们可得到f = [2, -1, 4]。

不难发现f[3] = 4 != nums[3] != f[2]*nums[3]，f[i]的值与f[i-1]的值无关，即DP状态最优值无法由更小规模的DP状态最优值推出，因此不符合最优子结构原则。

于是问题来了，怎样的状态定义财富和最优子结构呢？

继续思考可以发现，上述状态定义出错的原因主要是如果nums[i]为负数，则：f[i-1]*nums[i]只会越乘越小。

因此我们需要根据nums[i]正负值进行分类讨论：

- nums[i] > 0

  f[i] = max(nums[i], f[i-1]*nums[i])

- nums[i] < 0

  f[i] = max(nums[i], [以i-1为右端点的连续区间最小乘积]*nums[i])

由此可以发现，我们需要引入新的DP状态，令maxn[i]表示以i为右端点的连续区间最大乘积，minn[i]表示以i为右端点的连续区间的最小乘积。

不难发现maxn[i]、minn[i]的取值由maxn[i-1]、minn[i-1]的值推导而来，且与其具体的区间大小无关，因此同时满足最优子结构与无后效性原则。

最后我们再通过分类讨论即可确定如下DP转移方程：

if(nums[i] > 0) {

​	maxn[i] = max(nums[i], maxn[i-1] * nums[i]);

​	minn[i] = min(nums[i], minn[i-1] * nums[i]);

} else {

​	maxn[i] = max(nums[i], minn[i-1]*nums[i]);

​	minn[i] = min(nums[i], maxn[i-1]*nums[i]);

}

```c++
class Solution {
  public:
    vector<int> maxn, minn;
    int maxProduct(vector<int>& nums) {
        int n = nums.size(), ans = nums[0];
        maxn.resize(n); minn.resize(n);
        maxn[0] = minn[0] = nums[0];
        for(int i = 1; i < nums.size(); ++i) {
            if(nums[i] > 0) {
                maxn[i] = max(nums[i], maxn[i-1]*nums[i]);
                minn[i] = min(nums[i], minn[i-1]*nums[i]);
            } else {
                maxn[i] = max(nums[i], minn[i-1]*nums[i]);
                minn[i] = min(nums[i], maxn[i-1]*nums[i]);
            }
            ans = max(ans, maxn[i]);
        }
        return ans;
    }
};
```
















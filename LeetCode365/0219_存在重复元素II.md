# 219 存在重复元素II

给定一个整数数组和一个整数k，判断数组种是否存在两个不同的索引i和j，使得nums[i]=num[j]，并且i和j的差的绝对值至多为k。

方法一：线性搜索

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    for(int i = 0; i < nums.length; ++i) {
        for(int j = Math.max(i - k, 0); j < i; ++j) {
            if(nums[i] == nums[j]) return true;
        }
    }
    return false;
}
```

方法二：二分搜索

思路：通过平衡二叉搜索树来维护一个k大小的滑动窗口。

算法：这个方法的核心在于降低方法一中搜索前k个元素所耗费的时间。可以想一下，我们能不能用一个更复杂的数据结构来维持这个k大小的滑动窗口内元素的有序性呢?考虑到滑动窗口内元素是严格遵守先进先出的，那么队列会是一个非常自然就能想到的数据结构。链表实现的队列可以支持在常数时间内的删除、插入，然而搜索耗费的时间确实现行的，所以如果用队列来实现的话结果并不比方法更好。

一个更好的选择是使用自平衡二叉搜索树（BST）。BST中搜索、删除、插入都可以保持O(logk)的时间复杂度，其中k是BST中元素的个数。在大部分面试中你都不需要自己去实现一个 BST，所以把 BST 当成一个黑盒子就可以了。大部分的编程语言都会在标准库里面提供这些常见的数据结构。在 Java 里面，你可以用 TreeSet 或者是 TreeMap。在 C++ STL 里面，你可以用 std::set 或者是 std::map。

假设已经有了这样一个数据结构，则伪代码如下：

遍历数组，对每个元素做以下操作：

- 在 BST 中搜索当前元素，如果找到了就返回 `true`。
- 在 BST 中插入当前元素。
- 如果当前 BST 的大小超过了 k*k*，删除当前 BST 中最旧的元素。

返回 false。

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    Set<Integer> set = new TreeSet<>();
    for (int i = 0; i < nums.length; ++i) {
        if (set.contains(nums[i])) return true;
        set.add(nums[i]);
        if (set.size() > k) {
            set.remove(nums[i - k]);
        }
    }
    return false;
}
```

方法三：散列表

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    Set<Integer> set = new HashSet<>();
    for (int i = 0; i < nums.length; ++i) {
        if (set.contains(nums[i])) return true;
        set.add(nums[i]);
        if (set.size() > k) {
            set.remove(nums[i - k]);
        }
    }
    return false;
}
```


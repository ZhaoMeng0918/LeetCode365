# 面试题 08.01 散步问题

题目：三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。

解题思路：

**DP问题**思路主要就是确定DP状态与DP转移方程，因此首先考虑DP状态。

DP状态有两大原则：

- 最优子结构
- 无后效性

此问题要求出爬n阶台阶的总方案数，因此很容易想到子问题是爬i阶楼梯的总方案数。接下来再进一步验证该状态是否符合最优子结构与无后效性两大原则。



**DP状态**

f[i]：爬i阶楼梯的总方案数。

不难发现：f[i]的值仅由f[i-1]、f[i-2]、f[i-3]的值决定

符合最优子结构原则。

再进一步思考，f[i]的取值与f[i-1]、f[i-2]、f[i-3]的数值是如何得到的无关，因此符合无后效性原则。



**DP转移方程**

确定完DP状态后，我们再来确定DP转移方程。

由于小孩只有三种爬楼梯的选项，因此f[i]的值仅由f[i-3]~f[i-1]决定。且由于爬楼梯的最后一步不同，*因此f[i]的值由f[i-3]~f[i-1]累加得到*。

f[i] = (f[i-1] + f[i-2] + f[i-3]) % mod

注意：f[1] = 1, 且转移时需要注意f[i-1]、f[i-2]、f[i-3]不要越界



```c++
class Solution {
    public:
    	vector<int> f;
    	int mod = 1000000007;
    	int waysToStep(int n) {
            f.resize(n + 1);
            f[0] = 1;
            for(int i = 1; i <= n; i++) {
                f[i] = f[i - 1];
                if(i >= 2) f[i] = (f[i] + f[i - 2]) % mod;
                if(i >= 3) f[i] = (f[i] + f[i - 3]) % mod;
            }
            return f[n];
        }
}
```














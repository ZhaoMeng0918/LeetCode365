#  222 完全二叉树的节点个数

题目：

给出一个完全二叉树，求出该树的节点个数。



完全二叉树：

完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第h层，则该层包含1~2^h-1个节点。

优先级队列其实是个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满

对于情况一：可以直接用2^树深度-1来计算，注意这里的根节点深度为1

对于情况二：分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算



解释：

首先需要明确完全二叉树的定义：**它是一棵空树或者它的叶子节点只出在最后两层，若最后一层不满则叶子节点只在最左侧**。

再来回顾一下满二叉的节点个数怎么计算，如果满二叉树的层数为h，则总节点数为：2^h - 1.
那么我们来对 root 节点的左右子树进行高度统计，分别记为 left 和 right，有以下两种结果：

- left == right。这说明，左子树一定是满二叉树，因为节点已经填充到右子树了，左子树必定已经填满了。所以左子树的节点总数我们可以直接得到，是 2^left - 1，加上当前这个 root 节点，则正好是 2^left。再对右子树进行递归统计。
- left != right。说明此时最后一层不满，但倒数第二层已经满了，可以直接得到右子树的节点个数。同理，右子树节点 +root 节点，总数为 2^right。再对左子树进行递归查找。



```java
// 通用递归解法
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null) {
            return 0;
        }
        
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}

// 迭代法
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null) {
            return 0;
        }
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int result = 0;
        while(!queue.isEmpty()) {
            int size = queue.size();
            while(size-- > 0) {
                TreeNode cur = queue.poll();
                result++;
                if(cur.left != null) {
                    queue.offer(cur.left);
                }
                if(cur.right != null) {
                    queue.offer(cur.right);
                }
            }
        }
        return result;
    }
}

// 针对完全二叉树的解法
// 满二叉树的节点数为：2^depth - 1
public int countNodes(TreeNode root) {
    if(root == null) {
        return 0;
    }
    
    // 计算左右子树的层高
    int leftDepth = getDepth(root.left);
    int rightDepth = getDepth(root.right);
    if(leftDepth == rightDepth) { // 说明左子树一定是满二叉树
        return (1 << leftDepth) + countNodes(root.right);
    } else { // 
        return (1 << rightDepth) +countNodes(root.left);
    }
}

private int getDepth(TreeNode root) {
    int depth = 0;
    while(root != null) {
        root = root.left;
        depth++;
    }
    return depth;
}
```


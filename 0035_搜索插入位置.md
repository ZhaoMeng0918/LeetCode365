# 35 搜索插入位置

题目：给定一个**排序数组**和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为O(logn)的算法。



思路：这道题目不难，但是为什么通过率相对来说并不高呢？我理解是大家对边界处理的判断有所失误导致的。这道题目，要在数组中插入目标值，无非是这四种情况。

![35_搜索插入位置3](https://img-blog.csdnimg.cn/20201216232148471.png)

- 目标值在数组所有元素之前
- 目标值等于数组中某一个元素
- 目标值插入数组中的位置
- 目标值在数组所有元素之后

这四种情况确认清楚了，就可以尝试解题了。



##### 暴力解法

暴力解题不一定时间消耗就非常高，关键看实现的方式，就像是二分查找时间消耗不一定就很低，是一样的。

```c++
class Solution {
    public:
    	int searchInsert(vector<int>& nums, int target) {
            for(int i = 0; i < nums.size(); i++) {
                // 分别处理如下三种情况
                // 1. 目标值在数组所有元素之前
                // 2. 目标值等于数组中某一个元素
                // 3. 目标值插入数组中的位置
                if(nums[i] >= target) { // 一旦发现大于或等于target的nums[i]，那么i就是我们要的结果
                    return i;
                }
            }
            // 目标值在数组所有元素之后的情况
            return nums.size();
        }
}
```



##### 二分法

暴力解法的时间复杂度是O(n)，就要尝试一下二分查找法。

> 面试题里给出的数组是有序数组，都可以想一想是否可以使用二分法。
>
> 同时数组还要强调无重复元素，因为一旦有重复元素，使用二分查找发返回的元素下标可能不是唯一的。

```c++
// 第一种写法
class Solution {
    public:
    	int searchInsert(vector<int>& nums, int target) {
            int n = nums.size();
            int left = 0;
            int right = n - 1;
            while(left <= right) {
                int middle = left + ((right - left) / 2);
                if(nums[middle] > target) {
                    right middle - 1;
                } else if(nums[middle] < target) {
                    left = middle - 1;
                } else {
                    return middle;
                }
            }
            
            // 分别处理如下四种情况
            // 1. 目标值在数组所有元素之前 [0, -1]
            // 2. 目标值等于数组中某一个元素 return middle
            // 3. 目标值插入数组中的位置[left, right], return right + 1
            // 4. 目标值在数组所有元素之后的情况[left, right], return right + 1
            return right + 1;
        }
}

// 第二种写法
class Solution {
    public:
    	int searchInsert(vector<int>& nums, int target) {
            int n = nums.size();
            int left = 0;
            int right = n;
            while(left < right) {
                int middle = left + ((right - left) >> 1);
                if(nums[middle] > target) {
                    right = middle;
                } else if(nums[middle] < target) {
                    left = middle + 1;
                } else {
                    return middle;
                }
            }
            return right;
        }
}
```




























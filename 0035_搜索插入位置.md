# 35 搜索插入位置

**题目：**

给定一个**排序数组**和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为O(logn)的算法。



**思路：**

这道题目不难，但是为什么通过率相对来说并不高呢？我理解是大家对边界处理的判断有所失误导致的。这道题目，要在数组中插入目标值，无非是这四种情况。

![35_搜索插入位置3](https://img-blog.csdnimg.cn/20201216232148471.png)

- 目标值在数组所有元素之前
- 目标值等于数组中某一个元素
- 目标值插入数组中的位置
- 目标值在数组所有元素之后

这四种情况确认清楚了，就可以尝试解题了。



##### 暴力解法

暴力解题不一定时间消耗就非常高，关键看实现的方式，就像是二分查找时间消耗不一定就很低，是一样的。

```c++
class Solution {
    public:
    	int searchInsert(vector<int>& nums, int target) {
            for(int i = 0; i < nums.size(); i++) {
                // 分别处理如下三种情况
                // 1. 目标值在数组所有元素之前
                // 2. 目标值等于数组中某一个元素
                // 3. 目标值插入数组中的位置
                if(nums[i] >= target) { // 一旦发现大于或等于target的nums[i]，那么i就是我们要的结果
                    return i;
                }
            }
            // 目标值在数组所有元素之后的情况
            return nums.size();
        }
}
```



##### 二分法

暴力解法的时间复杂度是O(n)，就要尝试一下二分查找法。

> 面试题里给出的数组是**有序数组**，都可以想一想是否可以使用二分法。
>
> 同时数组还要强调**无重复元素**，因为一旦有重复元素，使用二分查找发返回的元素下标可能不是唯一的。

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int n = nums.length, low = 0, high = n - 1;
        while(low <= high) {
            int mid = low + ((high - low) >> 2); // 防止溢出
            if(nums[mid] > target) high = mid - 1;
            else if(nums[mid] < target) low = mid + 1;
            else return mid;
        }
        
        return high + 1;
    }
}

class Solution {
    public int searchInsert(int[] nums, int target) {
        int n = nums.length, low = 0, high = n;
        while(low < high) {
            int mid = low + ((high - low) >> 2); // 防止溢出
            if(nums[mid] > target) high = mid;
            else if(nums[mid] < target) low = mid + 1;
            else return mid;
        }
        
        return high;
    }
}
```




























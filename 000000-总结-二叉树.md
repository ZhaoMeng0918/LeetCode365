# 二叉树理论基础篇

#### 二叉树的种类

- 满二叉树

- 完全二叉树

  优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。

- 二叉搜索树

  二叉搜索树是一个有序树。

  - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
  - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
  - 它的左、右子树也分别为二叉排序树

- 平衡二叉搜索树

  AVL(Adelson-Velsky and Landis)，是一棵空树或它的左右两个子树的高度差绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

  C++中map、set、multimap、multiset的底层实现都是平衡二叉树，所以map、set的增删操作时间复杂度是logn。

  注意：使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，否则自己对其性能分析都无法分析。

#### 二叉树的存储方式

二叉树可以链式存储也可以顺序存储。

链式存储就是用指针，顺序存储就是用数组。

<img src="https://img-blog.csdnimg.cn/2020092019554618.png" alt="img" style="zoom:33%;" />

<img src="https://img-blog.csdnimg.cn/20200920200429452.png" alt="img" style="zoom: 33%;" />

#### 二叉树的遍历方式

二叉树主要有两种遍历方式：

1. 深度优先遍历

- 前序遍历（递归法、迭代法）
- 中序遍历（递归法、迭代法）
- 后续遍历（递归法、迭代法）

1. 广度优先遍历

- 层次遍历（迭代法）

这两种遍历是图论中最基本的两种遍历方式

#### 二叉树的定义

代码实现：

```java
public class TreeNode {
    int val;
  	TreeNode left;
  	TreeNode right;
  	TreeNode() {}
  	TreeNode(int val) { this.val = val; }
  	TreeNode(int val, TreeNode left, TreeNode right) {
    		this.val = val;
    		this.left = left;
    		this.right = right;
  	}
}
```



# 二叉树的递归遍历

递归三要素：

1. 确定递归函数的参数和返回值
2. 确定终止条件
3. 确定单层递归逻辑



前序遍历

```java
class Solution {
    ArrayList<Integer> preOrderReverse(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<Integer>();
        preOrder(root, result);
        return result;
    }
    void preOrder(TreeNode root, ArrayList<Integer> result) {
        if(root == null) {
            return;
        }
        result.add(root.val);
        preOrder(root.left, result);
        preOrder(root.right, result);
    }
}
```

中序遍历

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inorder(root, res);
        return res;
    }

    void inorder(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        inorder(root.left, list);
        list.add(root.val);
        inorder(root.right, list);
    }
}
```

后序遍历

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        postorder(root, res);
        return res;
    }

    void postorder(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        postorder(root.left, list);
        postorder(root.right, list);
        list.add(root.val);
    }
}
```

# 二叉树的迭代遍历

前序遍历

```java
class Solution {
    public List<Integer> preOrderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if(root == null) {
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            result.add(node.val);
            if(node.right != null) {
                stack.push(node.right);
            }
            if(node.left != null) {
                stack.push(node.left);
            }
        }
        return result;
    }
}
```

中序遍历

```java
class Solution {
    public List<Integer> inOrderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if(root == null) {
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while(cur != null || !stack.isEmpty()) {
            if(cur != null) {
                stack.push(cur);
                cur = cur.left;
            } else {
                cur = stack.pop();
                result.add(cur.val);
                cur = cur.right;
            }
        }
        return result;
    }
}
```

后序遍历

先序遍历是中左右，后序遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后再反转result数组，输出的结果顺序就是左右中了。

```java
class Solution {
    public List<Integer> postOrderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()) {
        	TreeNode node = stack.pop();
            result.add(node.val);
            if(node.left != null) {
                stack.push(node.left);
            }
            if(node.right != null) {
                stack.push(node.right);
            }
        }
        Collections.reverse(result);
        return result;
    }
}
```

# 二叉树的统一迭代法

前序遍历

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if(root != null) st.push(root);
        while(!st.empty()) {
            TreeNode node = st.peek();
            if(node != null) {
                st.pop();
                if(node.right != null) st.push(node.right);
                if(node.left != null) st.push(node.left);
                st.push(node);
                st.push(null);
            } else {
                st.pop();
                node = st.peek();
                st.pop();
                result.add(node.val);
            }
        }
        return result;
    }
}
```

中序遍历

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if(root != null) st.push(root);
        while(!st.empty()) {
            TreeNode node = st.peek();
            if(node != null) {
                st.pop();
                if(node.right != null) st.push(node.right);
                st.push(node);
                st.push(null);
                if(node.left != null) st.push(node.left);
            } else {
                st.pop();
                node = st.peek();
                st.pop();
                result.add(node.val);
            }
        }
        return result;
    }
}
```

后序遍历

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if(root != null) st.push(root);
        while(!st.empty()) {
            TreeNode node = st.peek();
            if(node != null) {
                st.pop();
                st.push(node);
                st.push(null);
                if(node.right != null) st.push(node.right);
                if(node.left != null) st.push(node.left);
            } else {
                st.pop();
                node = st.peek();
                st.pop();
                result.add(node.val);
            }
        }
        return result;
    }
}
```




























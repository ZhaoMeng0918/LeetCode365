# 53 最大子序和

**题目：**

给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。



暴力解法：

```c++
class Solution {
    public:
    	int maxSubArray(vector<int>& nums) {
            int result = INT32_MIN;
            int count = 0;
            for(int i = 0; i < nums.size(); i++) {
                count = 0;
                for(int j = i; j < nums.size(); j++) {
                    count += nums[j];
                    result = count > result ? count : result;
                }
            }
            return result;
        }
}
```



**贪心解法：**

如果 -2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！

局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。

全局最优：选取最大“连续和”。

**局部最优的情况下，并记录最大的“连续和”，可以推出全局最优**。

从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。

**这相当于是暴力解法中的不断调整最大子序和区间的起始位置**。

**那有同学问了，区间终止位置不用调整么？ 如何才能得到最大“连续和”呢？**

区间的终止位置，其实就是如果count取到最大值了，及时记录下来了。例如如下代码：

```text
if (count > result) result = count;
```

**这样相当于是用result记录最大子序和区间和（变相的算是调整了终止位置）**。

![53.最大子序和](https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif)

红色的起始位置就是贪心每次取count为正数的时候，开始一个区间的统计。



**代码实现：**

```c++
class Solution {
    public:
    	int maxSubArray(vector<int>& nums) {
            int result = INT32_MIN;
            int count = 0;
            for(int i = 0; i < nums.size(); i++) {
                count += nums[i];
                if(count > result) { // 取区间累计的最大值（相当于不确定最大子序终止位置）
                    result = count;
                }
                if(count <= 0) count = 0; // 相当于重制最大子序起始位置，因为遇到负数一定是拉低总和
            }
   		 	return result;
        }
}
```



**动态规划：**




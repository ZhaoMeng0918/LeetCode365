# 104 二叉树的最大深度

题目：

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。



递归法：

**本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的是深度，使用后序求得是高度。**

**而根节点的高度就是二叉树的最大深度**，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。



使用后序遍历来计算树的高度

确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型

```c++
int getdepth(treenode* node)
```



确定终止条件：如果为空节点的话，就返回0，表示高度为0

```c++
if(node == null) return 0;
```



确定单层递归的逻辑：先求它的左子树的深度，再求的右子树的深度，最后取左右深度最大的数值，再+1（加1是因为算上当前中间节点）就是目前节点为根节点的树的深度

```c++
int leftdepth = getdepth(node->left); // 左
int rightdepth = getdepth(node->right); // 右
int depth = 1 + max(leftdepth, rightdepth);
return depth;
```



总结：后序遍历

1. 确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型
2. 确定终止条件：如果为空节点的话，就返回0，表示高度为0
3. 确定他单层递归的逻辑：先求它的左子树的深度，再求右子树的深度，最后取左右深度最大的数值，再+1.

```c++
class solution {
public:
    int getdepth(treenode* node) {
        if (node == null) return 0;
        int leftdepth = getdepth(node->left);       // 左
        int rightdepth = getdepth(node->right);     // 右
        int depth = 1 + max(leftdepth, rightdepth); // 中
        return depth;
    }
    int maxdepth(treenode* root) {
        return getdepth(root);
    }
};

// 精简后的代码
class solution {
    public:
    	int maxdepth(treenode* root) {
            if(root == null) return 0;
            return 1 + max(maxdepth(root->left), maxdepth(root->right));
        }
};
```

前序遍历

```c++
// 前序
class solution {
public:
    int result;
    void getdepth(treenode* node, int depth) {
        result = depth > result ? depth : result; // 中

        if (node->left == null && node->right == null) return ;

        if (node->left) { // 左
            depth++;    // 深度+1
            getdepth(node->left, depth);
            depth--;    // 回溯，深度-1
        }
        if (node->right) { // 右
            depth++;    // 深度+1
            getdepth(node->right, depth);
            depth--;    // 回溯，深度-1
        }
        return ;
    }
    int maxdepth(treenode* root) {
        result = 0;
        if (root == 0) return result;
        getdepth(root, 1);
        return result;
    }
};
```





迭代法：

使用迭代法的话，层序遍历是最合适的。因为最大深度就是二叉树的层数，和层序遍历的方式极其吻合。

在二叉树中，一层层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度。

<img src="https://img-blog.csdnimg.cn/20200810193056585.png" alt="层序遍历" style="zoom:33%;" />

```c++
class solution {
    public:
    	int maxdepth(treenode* root) {
            if(root == null) return 0;
            int depth = 0;
            queue<treenode*> que;
            que.push(root);
            while(!que.empty()) {
                int size = que.size();
                depth++;
                for(int i = 0; i < size; i++) {
                    treenode* node = que.front();
                    que.pop();
                    if(node->left) que.push(node->left);
                    if(node->right) que.push(node->right);
                }
            }
            return depth;
        }
};
```


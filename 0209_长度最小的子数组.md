# 209 长度最小的子数组

题目：给定一个含有n个正整数的数组和一个正整数s，找出该数组中满足和>=s的长度*最小的连续子数组*，并返回其长度。如果不存在符合条件的子数组，返回0。

示例：输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。



**注意：涉及连续子数组的问题，我们通常有两种思路：一是滑动窗口、二是前缀和。**



##### 暴力解法：

```c++
class Solution {
    public:
    	int minSubArrayLen(int s, vector<int>& nums) {
            int result = INT32_MAX; // 最终的结果
            int sum = 0;            // 子序列的数值之和
            int subLength = 0;      // 子序列的长度
            for(int i = 0; i < nums.size(); i++) {
                sum = 0;
                for(int j = i; j < nums.size(); j++) {
                    sum += nums[j];
                    if(sum >= s) {
                        subLength = j - i + 1;
                        result = result < subLength ? result : subLength;
                        break;
                    }
                }
            }
            return result == INT32_MAX ? 0 : result;
        }
}
```

##### 滑动窗口

所谓滑动窗口，就是不断调节子序列的起始位置和终止位置，从而得出我们想要的结果。

这里还是以题目中的示例来举例：s = 7，数组是2，3，1，2，4，3，来看一下查找过程：

![209.长度最小的子数组](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

从动画中可以发现滑动窗口也可以理解为双指针法的一种，只不过这种解法更像是一个窗口的移动。

在本题中实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

窗口就是满足其和>=s的长度最小的连续数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。



解题的关键在于，窗口的起始位置如何移动，如图所示：

![leetcode_209](https://img-blog.csdnimg.cn/20210312160441942.png)

可以发现，滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法将为O(n)。

```c++
class Solution {
    public:
    	int minSubArrayLen(int s, vector<int>& nums) {
            int result = INT32_MAX;
            int sum = 0;
            int i = 0;
            int subLength;
            for(int j = 0; j < nums.size(); j++) {
                sum += nums[j];
                while(sum >= s) {
                    subLength = (j - i + 1);
                    result = result < subLength ? result : subLength;
                    sum -= nums[i++];
                }
            }
            return result == INT32_MAX ? 0 : result;
        }
}
```

##### 前缀和+二分查找

暴力解法的时间复杂度是O(n2)，因为在确定每个子数组的开始下标后，找到长度最小的子数组需要O(n)的时间。如果使用二分查找，则可以将时间优化到O(logn)。

解释1：为了使用二分查找，需要额外创建一个数组sums用于存储数组nums的前缀和，其中sums[i]表示从nums[0]到nums[i-1]的元素和。得到前缀和之后，对于每个开始下标i，可通过二分查找得到大于或等于i的最小下标bound，使得sums[bound] - sums[i-1] >= s，并更新子数组的最小长度（此时子数组的长度是bound - (i-1))。

解释2：我们申请一个临时数组 sums，其中 sums[i] 表示的是原数组 nums 前 i 个元素的和，题中说了 “给定一个含有 n 个 正整数 的数组”，既然是正整数，那么相加的和会越来越大，也就是sums数组中的元素是递增的。我们只需要找到 sums[k]-sums[j]>=s，那么 k-j 就是满足的连续子数组，但不一定是最小的，所以我们要继续找，直到找到最小的为止。



**因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这点保证了二分的正确性。如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了。**

```java
class Soultion {
    public int minSubArrayLen(int s, int[] nums) {
        int n = nums.length;
        if(n == 0) {
            return 0;
        }
        int ans = Integer.MAX_VALUE;
        int[] sums = new int[n+1];
        // 为了方便计算，令size = n + 1
        // sums[0] = 0 意味着前0个元素前缀和为0
        // sums[1] = A[0] 前1个元素的前缀和为A[0]
        // 以此类推
        for(int i = 1; i <= n; i++) {
            sums[i] = sums[i - 1] + nums[i - 1];
        }
        for(int i = 1; i <= n; i++) {
            int target = s + sums[i - 1]; // sums[k] - sums[j] >= s => sums[j] + s <= sums[k]
            int bound = Arrays.binarySearch(sums, target); // 找到就返回下标，没找到返回一个负数，取反就是在数组中的位置
            if(bound < 0) {
                bound = -bound - 1;
            }
            if(bound <= n) {
                ans = Math.min(ans, bound - (i - 1));
            }
        }
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
}
```

##### 直接使用窗口

滑动窗口使用的是两个指针，每次往串口添加元素来判断是否满足。其实我们可以逆向思维，先固定一个窗口大小比如leng，然后遍历数组，查看在数组中leng个元素长度和是否有满足的，如果没有满足的我们就扩大窗口的大小继续查找，如果又满足我们就记录记录下窗口的大小leng，因为这个leng不一定是最小的，我们要缩小窗口的大小再继续寻找。

```java
public int minSubArrayLen(int s, int[] nums) {
    int lo = 1, hi = nums.length, min = 0;
    while(lo <= hi) {
        int mid = (lo + hi) >> 1;
        if(windowExist(mid, nums, s)) {
            hi = mid - 1;
            min = mid;
        } else {
            lo = mid + 1;
        }
    }
    return min;
}

private boolean windowExist(int size, int[] nums, int s) {
    int sum = 0;
    for(int i = 0; i < nums.length; i++) {
        if(i >= size) {
            sum -= nums[i - size];
        }
        sum += nums[i];
        if(sum >= s) {
            return true;
        }
    }
    return false;
}
```








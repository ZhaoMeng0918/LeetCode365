# 209 长度最小的子数组

**题目：**

给定一个含有n个正整数的数组和一个正整数s，找出该数组中满足和>=s的长度*最小的连续子数组*，并返回其长度。

如果不存在符合条件的子数组，返回0。



示例：输入：s = 7, nums = [2, 3, 1, 2, 4, 3] 输出：2 

解释：子数组 [4, 3] 是该条件下的长度最小的子数组。



**注意：涉及连续子数组的问题，我们通常有两种思路：**

**一、滑动窗口**

**二、前缀和**



暴力解法：

```c++
class Solution {
    public:
    	int minSubArrayLen(int s, vector<int>& nums) {
            int result = INT32_MAX; // 最终的结果
            int sum = 0;            // 子序列的数值之和
            int subLength = 0;      // 子序列的长度
            
            // O(n^2)
            for(int i = 0; i < nums.size(); i++) {
                sum = 0;
                for(int j = i; j < nums.size(); j++) {
                    sum += nums[j];
                    if(sum >= s) {
                        subLength = j - i + 1;
                        result = result < subLength ? result : subLength;
                        break;
                    }
                }
            }
            
            return result == INT32_MAX ? 0 : result;
        }
}
```



滑动窗口

```c++
class Solution {
    public:
    	int minSubArrayLen(int s, vector<int>& nums) {
            int result = INT32_MAX;
            int sum = 0;
            int i = 0;
            int subLength;
            
            for(int j = 0; j < nums.size(); j++) {
                sum += nums[j];
                while(sum >= s) {
                    subLength = (j - i + 1);
                    result = result < subLength ? result : subLength;
                    sum -= nums[i++];
                }
            }
            
            return result == INT32_MAX ? 0 : result;
        }
}
```



前缀和+二分查找

暴力解法的时间复杂度是O(n2)，因为在确定每个子数组的开始下标后，找到长度最小的子数组需要O(n)的时间。如果使用二分查找，则可以将时间优化到O(logn)。

解释1：为了使用二分查找，需要额外创建一个数组sums用于存储数组nums的前缀和，其中sums[i]表示从nums[0]到nums[i-1]的元素和。得到前缀和之后，对于每个开始下标i，可通过二分查找得到大于或等于i的最小下标bound，使得sums[bound] - sums[i-1] >= s，并更新子数组的最小长度（此时子数组的长度是bound - (i-1))。

解释2：我们申请一个临时数组 sums，其中 sums[i] 表示的是原数组 nums 前 i 个元素的和，题中说了 “给定一个含有 n 个 正整数 的数组”，既然是正整数，那么相加的和会越来越大，也就是sums数组中的元素是递增的。我们只需要找到 sums[k]-sums[j]>=s，那么 k-j 就是满足的连续子数组，但不一定是最小的，所以我们要继续找，直到找到最小的为止。



**因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这点保证了二分的正确性。如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了。**

```java
class Soultion {
    public int minSubArrayLen(int s, int[] nums) {
        int n = nums.length;
        if(n == 0) {
            return 0;
        }
        
        int ans = Integer.MAX_VALUE;
        int[] sums = new int[n+1];
        
        // 前缀和
        for(int i = 1; i <= n; i++) {
            sums[i] = sums[i - 1] + nums[i - 1];
        }
        
        for(int i = 1; i <= n; i++) {
            // sums[k]-sums[j] >= s -----> s + sums[j] <= sim[k]
            int target = s + sums[i - 1];
            // 找到就返回下标，没找到返回一个负数，取反就是在数组中的位置
            int bound = Arrays.binarySearch(sums, target); // binarySearch是二分查找
            
            if(bound < 0) {
                bound = -bound - 1;
            }
            
            if(bound <= n) {
                ans = Math.min(ans, bound - (i - 1));
            }
        }
        
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
}
```



直接使用窗口

滑动窗口使用的是两个指针，每次往串口添加元素来判断是否满足。

其实我们可以逆向思维，先固定一个窗口大小比如leng，然后遍历数组，查看在数组中leng个元素长度和是否有满足的，如果没有满足的我们就扩大窗口的大小继续查找，如果又满足我们就记录记录下窗口的大小leng，因为这个leng不一定是最小的，我们要缩小窗口的大小再继续寻找。

```java
public int minSubArrayLen(int s, int[] nums) {
    int lo = 1, hi = nums.length, min = 0;
    while(lo <= hi) {
        int mid = (lo + hi) >> 1;
        if(windowExist(mid, nums, s)) {
            hi = mid - 1;
            min = mid;
        } else {
            lo = mid + 1;
        }
    }
    return min;
}

private boolean windowExist(int size, int[] nums, int s) {
    int sum = 0;
    for(int i = 0; i < nums.length; i++) {
        if(i >= size) {
            sum -= nums[i - size];
        }
        sum += nums[i];
        if(sum >= s) {
            return true;
        }
    }
    return false;
}
```








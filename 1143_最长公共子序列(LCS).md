# 1143 最长公共子序列（LCS)

**题目：**

给定两个字符串text1和text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下，删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace"是"abcde"的子序列，但"aec"不是"abcde"的子序列。

两个字符串的公共子序列是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回0。



**解题思路：**

求两个数组或者字符串的最长公共子序列问题，肯定是要用动态规划的。

- 首先，区分两个概念：子序列可以是不连续的；子数组（子字符串）需要时连续的；
- 另外，动态规划也是有套路的；单个数组或者字符串要用动态规划时，可以把动态规划dp[i]定义为nums[0:i]中想要求的结果；当两个数组或者字符串要用动态规划时，可以把动态规划定义成两维的dp\[i][j]，其含义是在A[0:i]与B[0:j]之间匹配得到想要的结果。



**状态定义：**

比如对于本题而言，可以定义dp\[i][j]表示text1[0:i-1]和text2[0:j-1]的最长公共子序列。（注：text1[0:i-1]表示的是text1的第0个元素到第i-1个元素，两端都包含），之所以dp\[i][j]的定义不是text1[0:i]和text2[0:j]，是为了方便当i=0或者j=0的时候，dp\[i][j]表示的为空字符串和另外一个字符串的匹配，这样dp\[i][j]可以初始化为0。



**状态转移方程：**

- 当text1[i-1] == text2[j-1]时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了1，所以dp\[i][j] = dp\[i-1][j-1] + 1；举个例子，比如ac和bc而言，他们的最长公共子序列的长度等于a和b的最长公共子序列长度0 + 1= 1。
- 当text1[i-1] != text2[j-1]时，说明两个子字符串的最后一位不相等，那么此时的状态dp\[i][j]应该是dp\[i-1][j]和dp\[i][j-1]的最大值。举个例子，比如对于ace和bc而言，他们的最长公共子序列的长度等于1. ace和b的最长公共子序列长度0与2. ac和bc的最长公共子序列长度1的最大值，即1。

综上所述状态转移方程为:

- dp\[i][j] = dp\[i-1][j--1] + 1，当text1[i-1] == text2[j-1];
- dp\[i][j] = max(dp\[i-1][j], dp\[i][j-1])，当text1[i-1] != text2[j-1];



**状态的初始化：**

初始化就是要看当 i = 0 与 j = 0 时， dp\[i][j] 应该取值为多少。

当 i = 0 时，dp\[0][j] 表示的是 text1 中取空字符串 跟 text2 的最长公共子序列，结果肯定为 0.
当 j = 0 时，dp\[i][0] 表示的是 text2 中取空字符串 跟 text1 的最长公共子序列，结果肯定为 0.
综上，当 i = 0 或者 j = 0 时，dp[i][j] 初始化为 0.



**遍历方向与范围：**

由于 dp\[i][j] 依赖与 dp\[i - 1][j - 1] , dp\[i - 1][j], dp\[i][j - 1]，所以 i 和 j 的遍历顺序肯定是从小到大的。
另外，由于当 i 和 j 取值为 0 的时候，dp\[i][j] = 0，而 dp 数组本身初始化就是为 0，所以，直接让 i 和 j 从 1 开始遍历。遍历的结束应该是字符串的长度为 len(text1) 和 len(text2)。



**最终返回结果：**

由于 dp\[i][j] 的含义是 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列。我们最终希望求的是 text1 和 text2 的最长公共子序列。所以需要返回的结果是 i = len(text1) 并且 j = len(text2) 时的 dp\[len(text1)][len(text2)]。

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int M = text1.length();
        int N = text2.length();
        int[][] dp = new int[M + 1][N + 1];
        for (int i = 1; i <= M; ++i) {
            for (int j = 1; j <= N; ++j) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[M][N];
    }
}
```

时间复杂度：O(mn)

空间复杂度：O(mn)



```c++
class Solution {
    public:
    	int longestCommonSubsequence(string text1, string text2) {
            int n = text1.length(), m = text2.length();
            vector<vector<int>> f(n+1, vector<int>(m+1, 0));
            for(int i = 1; i <= n; i++) {
                for(int j = 1; j <= m; j++) {
                    f[i][j] = max(f[i-1][j], f[i][j-1]);
                    if(text1[i-1] == text2[j-1]) {
                        f[i][j] = max(f[i][j], f[i-1][j-1] + 1);
                    }
                }
            }
            return f[n][m];
        }
}
```


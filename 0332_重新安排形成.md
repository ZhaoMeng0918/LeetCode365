# 332 重新安排行程

**题目：**

给定一个机票的字符串二维数组[from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点。

对该行程进行重新规划排序。所有这些机票都属于一个从JFK出发的先生，所以该行程必须从JDK开始。



提示：

- 如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前
- 所有的机场都用三个大写字母表示（机场代码）。
- 假定所有机票至少存在一种合理的行程。
- 所有的机票必须都用一次 且 只能用一次。



示例 1：

- 输入：[["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
- 输出：["JFK", "MUC", "LHR", "SFO", "SJC"]

示例 2：

- 输入：[["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
- 输出：["JFK","ATL","JFK","SFO","ATL","SFO"]
- 解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"]。但是它自然排序更大更靠后。



**思路：**

直觉上来看，这道题和回溯法没有什么关系，更像是图论中的深度优先搜索。

实际上确实是深搜，但这是深搜中使用了回溯的例子，在查找路径的时候，如果不回溯，怎么能查到目标的路径呢。



这道题有几个难点：

1. 一个行程中，如果航班处理不好容易变成一个圈，成为死循环。
2. 有多种解法，字母序靠前排名在前面，如何该记录映射关系呢？
3. 使用回溯法的话，终止条件是什么？
4. 搜索的过程中，如何遍历一个机场对应的所有机场。



**代码实现：**

```java
class Solution {
    private Deque<String> res;
    private Map<String, Map<String, Integer>> map;
    
    private boolean backTracking(int ticketNum) {
        if(res.size() == ticketNum + 1) {
            return true;
        }
        
        String last = res.getLast();
        if(map.containsKey(last)) {
            for(Map.Entry<String, Integer> target : map.get(last).entrySet()) {
                int count = target.getValue();
                if(count > 0) {
                    res.add(target.getKey());
                    target.setValue(count - 1);
                    if(backTracking(ticketNum)) return true;
                    res.removeLast();
                    target.setValue(count);
                }
            }
        }
        return false;
    }
    
    public List<String> findItinerary(List<List<String>> tickets) {
        map = new HashMap<String, Map<String, Integer>>();
        res = new LinkedList<>();
        
        // 思路是按照key的优先级进行排序处理了
        for(List<String> t : tickets) {
            Map<String, Integer> temp;
            // 一个key对应多个value
            if(map.containsKey(t.get(0))) {
                // 把value拿出来
                temp = map.get(t.get(0));
                // 因为底层采用的是红黑树，
                temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);
            } else {
                temp = new TreeMap<>();
                temp.put(t.get(1), 1);
            }
            map.put(t.get(0), temp);
        }
        
        res.add("JFK");
        backTracking(tickets.size());
        return new ArrayList<>(res);
    }
}
```



补充说明：

**红黑树是一种自平衡二叉搜索树，其Key值是有序的**。











